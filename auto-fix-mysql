#!/usr/bin/env python
# encoding: utf-8

import os
import sys
import shutil
import traceback
import subprocess

from datetime import datetime

import psutil
import mysql.connector


MYSQL_MYSQL_DB_DIR = "/var/lib/mysql/mysql"
MYSQL_BACKUP_DIR = "/etc/yunohost/auto-fix-mysql/mysql-db-backup/"
MYSQL_BROKEN_DIR = "/etc/yunohost/auto-fix-mysql/mysql-db-broken/"


def mysql_is_running():
    return len([x for x in psutil.process_iter() if x.name().lower() == "mysqld"]) > 0


def mysql_is_broken():
    if mysql_is_running():
        return False

    return subprocess.call(["service", "mysql", "start"]) != 0


def backup_mysql_db():
    connection = mysql.connector.connect(
        user='root',
        password=open("/etc/yunohost/mysql", "r").read().strip(),
        host='127.0.0.1',
        database='mysql'
    )

    cursor = connection.cursor()

    try:
        cursor.execute("show tables")

        # can't lock log tables
        tables = [x[0] for x in cursor.fetchall() if not x[0].endswith("log")]

        sql = "LOCK TABLES %s READ;" % " READ,".join(tables)
        cursor.execute(sql)

        if not os.path.exists(MYSQL_BACKUP_DIR):
            os.makedirs(MYSQL_BACKUP_DIR)

        subprocess.check_call(["rsync", "-a", MYSQL_MYSQL_DB_DIR, MYSQL_BACKUP_DIR])

    except Exception as e:
        traceback.print_exc(file=sys.stdout)
        print e

    finally:
        cursor.execute("UNLOCK TABLES")

        cursor.close()
        connection.close()


def there_is_a_backup():
    return os.path.exists(os.path.join(MYSQL_BACKUP_DIR, "mysql"))


def fix_mysql():
    if there_is_a_backup():
        print "Yay, we have a backup of mysql, let's use it \o/"
        fix_mysql_using_back()


def fix_mysql_using_back():
    assert not mysql_is_running()

    broken_backup_target_dir = os.path.join(MYSQL_BROKEN_DIR, datetime.now().strftime("%F_%X").replace(":", "-"))

    if not os.path.exists(MYSQL_BROKEN_DIR):
        os.makedirs(MYSQL_BROKEN_DIR)

    print "Save old broken db in %s..." % broken_backup_target_dir
    shutil.move(MYSQL_MYSQL_DB_DIR, broken_backup_target_dir)

    print "Restore working db..."
    shutil.copytree(os.path.join(MYSQL_BACKUP_DIR, "mysql"), MYSQL_MYSQL_DB_DIR)
    subprocess.check_call(["chown", "-R", "mysql:mysql", os.path.join(MYSQL_MYSQL_DB_DIR)])

    print "Trying to restart mysql..."
    result = subprocess.call(["service", "mysql", "start"])

    if result == 0:
        print "Success!"
    else:
        # TODO : switch to manual reverse fixing
        mysql_logs = "/var/lib/mysql/%s.err" % (subprocess.check_output(["hostname"]).strip())
        print "Huho, I've failed :("
        print "Go look at https://wiki.labriqueinter.net/doku.php/howto:fix_self_corrupt_mysql for more informations"

        if os.path.exists(mysql_logs):
            print
            message = "Display last 40 lines of mysql logs from %s:" % mysql_logs
            print message
            print "=" * len(message)
            subprocess.call(["tail", "-n", "40", mysql_logs])
        else:
            print "MySQL usually store it's failed starting log inside %s" % mysql_logs


if __name__ == '__main__':
   if not mysql_is_broken():
       backup_mysql_db()
   else:
       print "Damn, mysql is broken, attempting restore!"
       fix_mysql()
